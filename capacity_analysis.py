"""
capacity_analysis.py - Link capacity calculations

This module implements Shannon capacity calculations with complete link budget
analysis, including transmitter power, antenna gains, path loss, and noise.

Author: Nipun Agarwal
Version: 1.0
"""

import numpy as np
from typing import Dict, Tuple
from config import (
    PhysicalConstants,
    LinkBudgetConfig,
    FrequencyConfig,
    EnvironmentalParams,
)
from antenna_models import EnhancedAntennaArray
from channel_models import EnhancedPathLossModel


class CapacityAnalyzer:
    """
    Shannon capacity calculator for THz wireless links.

    This class implements the complete link budget calculation from transmitter
    to receiver, culminating in the Shannon capacity formula:

        C = B × log₂(1 + SNR)

    where:
        C is capacity in bits per second
        B is bandwidth in hertz
        SNR is signal-to-noise ratio (linear, not dB)

    The link budget follows the Friis transmission equation:

        P_rx = P_tx + G_tx + G_rx - PL_total

    where all values are in dB or dBm. The noise power is calculated using
    the thermal noise formula:

        N = k × T × B × F

    where k is Boltzmann's constant, T is temperature, B is bandwidth, and
    F is the receiver noise figure.
    """

    def __init__(
        self,
        tx_power_dbm: float = None,
        noise_figure_db: float = None,
        bandwidth_ghz: float = None,
        env_params: EnvironmentalParams = None,
    ):
        """
        Initialize capacity analyzer with link parameters.

        Parameters:
        -----------
        tx_power_dbm : float, optional
            Transmit power in dBm (defaults to configured value)
        noise_figure_db : float, optional
            Receiver noise figure in dB (defaults to configured value)
        bandwidth_ghz : float, optional
            Channel bandwidth in GHz (defaults to configured value)
        env_params : EnvironmentalParams, optional
            Environmental conditions (defaults to standard atmosphere)
        """
        self.tx_power_dbm = (
            tx_power_dbm
            if tx_power_dbm is not None
            else LinkBudgetConfig.DEFAULT_TX_POWER_DBM
        )
        self.noise_figure_db = (
            noise_figure_db
            if noise_figure_db is not None
            else LinkBudgetConfig.DEFAULT_NOISE_FIGURE_DB
        )
        self.bandwidth_ghz = (
            bandwidth_ghz
            if bandwidth_ghz is not None
            else FrequencyConfig.DEFAULT_BANDWIDTH_GHZ
        )

        self.env_params = (
            env_params if env_params is not None else EnvironmentalParams()
        )

        # Convert to linear and Hz
        self.tx_power_w = 10 ** (self.tx_power_dbm / 10) / 1000
        self.noise_figure_linear = 10 ** (self.noise_figure_db / 10)
        self.bandwidth_hz = self.bandwidth_ghz * 1e9

    def compute_thermal_noise(self) -> Tuple[float, float]:
        """
        Calculate thermal noise power using the Nyquist-Johnson formula.

        The thermal noise power is the fundamental limit on receiver sensitivity.
        It arises from random thermal motion of electrons in the receiver circuits.

        Formula: N = k × T × B × F

        where:
        - k = 1.38×10⁻²³ J/K (Boltzmann's constant)
        - T = temperature in Kelvin
        - B = bandwidth in Hz
        - F = noise figure (linear, not dB)

        The noise figure F accounts for additional noise generated by the receiver
        components beyond the theoretical thermal noise. Typical values:
        - Low-noise amplifiers: 3-6 dB (factor of 2-4)
        - Standard receivers: 8-12 dB (factor of 6-16)

        Returns:
        --------
        noise_power_w : float
            Noise power in watts
        noise_power_dbm : float
            Noise power in dBm
        """
        noise_power_w = (
            PhysicalConstants.BOLTZMANN_CONSTANT
            * self.env_params.temperature_k
            * self.bandwidth_hz
            * self.noise_figure_linear
        )

        noise_power_dbm = 10 * np.log10(noise_power_w * 1000)

        return noise_power_w, noise_power_dbm

    def compute_link_budget(
        self,
        frequency_ghz: float,
        distance_m: float,
        tx_array_size_cm: float,
        rx_array_size_cm: float,
        rain_mm_hr: float = 0.0,
    ) -> Dict:
        """
        Perform complete link budget calculation.

        This method brings together all the components: antenna gains from both
        ends, path loss through the channel, received signal power, noise power,
        SNR, and finally Shannon capacity.

        The calculation proceeds in stages:
        1. Calculate TX and RX antenna gains
        2. Calculate total path loss (FSPL + absorption + rain)
        3. Apply Friis equation: P_rx = P_tx + G_tx + G_rx - PL
        4. Calculate noise power
        5. Calculate SNR = P_rx / N
        6. Calculate capacity = B × log₂(1 + SNR)

        Parameters:
        -----------
        frequency_ghz : float
            Operating frequency in GHz
        distance_m : float
            Link distance in meters
        tx_array_size_cm : float
            Transmitter array size in cm
        rx_array_size_cm : float
            Receiver array size in cm
        rain_mm_hr : float, optional
            Rain rate in mm/hr (default: 0)

        Returns:
        --------
        results : dict
            Complete link budget with all intermediate values
        """
        # Create antenna arrays
        tx_antenna = EnhancedAntennaArray(tx_array_size_cm, frequency_ghz)
        rx_antenna = EnhancedAntennaArray(rx_array_size_cm, frequency_ghz)

        # Get antenna gains
        tx_gain_dbi = tx_antenna.compute_gain_dbi()
        rx_gain_dbi = rx_antenna.compute_gain_dbi()

        # Calculate path loss
        path_model = EnhancedPathLossModel(self.env_params)
        path_loss_dict = path_model.compute_total_loss(
            frequency_ghz, distance_m, rain_mm_hr
        )
        path_loss_total_db = path_loss_dict["total"]

        # Apply Friis equation (all in dB/dBm)
        rx_power_dbm = (
            self.tx_power_dbm + tx_gain_dbi + rx_gain_dbi - path_loss_total_db
        )
        rx_power_w = 10 ** (rx_power_dbm / 10) / 1000

        # Calculate noise
        noise_power_w, noise_power_dbm = self.compute_thermal_noise()

        # Calculate SNR
        snr_linear = rx_power_w / noise_power_w
        snr_db = 10 * np.log10(snr_linear) if snr_linear > 0 else -100

        # Calculate Shannon capacity
        capacity_bps = self.bandwidth_hz * np.log2(1 + snr_linear)
        capacity_gbps = capacity_bps / 1e9

        # Calculate spectral efficiency (bits/s/Hz)
        spectral_efficiency = capacity_bps / self.bandwidth_hz

        # Calculate link margin (how much SNR we have above minimum required)
        # Typically, we need SNR ≈ 10 dB for reliable communication
        link_margin_db = snr_db - 10.0

        return {
            # Transmitter
            "tx_power_dbm": self.tx_power_dbm,
            "tx_gain_dbi": tx_gain_dbi,
            "tx_array_size_cm": tx_array_size_cm,
            # Channel
            "frequency_ghz": frequency_ghz,
            "distance_m": distance_m,
            "path_loss_total_db": path_loss_total_db,
            "path_loss_fspl_db": path_loss_dict["fspl"],
            "path_loss_absorption_db": path_loss_dict["absorption"],
            "path_loss_rain_db": path_loss_dict["rain"],
            # Receiver
            "rx_gain_dbi": rx_gain_dbi,
            "rx_array_size_cm": rx_array_size_cm,
            "rx_power_dbm": rx_power_dbm,
            "rx_power_w": rx_power_w,
            # Noise and SNR
            "noise_power_dbm": noise_power_dbm,
            "noise_power_w": noise_power_w,
            "noise_figure_db": self.noise_figure_db,
            "snr_db": snr_db,
            "snr_linear": snr_linear,
            # Capacity
            "bandwidth_ghz": self.bandwidth_ghz,
            "capacity_gbps": capacity_gbps,
            "capacity_bps": capacity_bps,
            "spectral_efficiency": spectral_efficiency,
            "link_margin_db": link_margin_db,
        }

    def find_required_array_size(
        self, frequency_ghz: float, distance_m: float, target_capacity_gbps: float
    ) -> Tuple[float, Dict]:
        """
        Determine minimum array size needed to achieve target capacity.

        This is a critical design tool for backhaul links. Given requirements
        (frequency, distance, target capacity), it finds the minimum antenna
        array size needed. This is useful for cost optimization since larger
        arrays are more expensive.

        The method uses binary search to efficiently find the required size.

        Parameters:
        -----------
        frequency_ghz : float
            Operating frequency in GHz
        distance_m : float
            Link distance in meters
        target_capacity_gbps : float
            Desired capacity in Gbps

        Returns:
        --------
        required_size_cm : float
            Minimum array size in cm (assumes TX and RX are equal)
        link_budget : dict
            Complete link budget at the found size
        """
        # Binary search for required size
        low, high = 0.5, 50.0  # Search range: 0.5 cm to 50 cm

        while high - low > 0.1:  # Converge to within 0.1 cm
            mid = (low + high) / 2

            # Calculate capacity with this array size
            result = self.compute_link_budget(frequency_ghz, distance_m, mid, mid)

            if result["capacity_gbps"] < target_capacity_gbps:
                # Need larger array
                low = mid
            else:
                # Array is sufficient
                high = mid

        # Use the final size and calculate complete link budget
        final_size = (low + high) / 2
        final_result = self.compute_link_budget(
            frequency_ghz, distance_m, final_size, final_size
        )

        return final_size, final_result


def compute_capacity_vs_parameter(
    analyzer: CapacityAnalyzer,
    parameter_name: str,
    parameter_values: np.ndarray,
    base_config: Dict,
) -> np.ndarray:
    """
    Calculate capacity as a function of a single parameter.

    This utility function is useful for generating plots showing how capacity
    varies with frequency, distance, array size, etc., while keeping all other
    parameters constant.

    Parameters:
    -----------
    analyzer : CapacityAnalyzer
        Capacity analyzer instance
    parameter_name : str
        Name of parameter to vary ('frequency_ghz', 'distance_m', 'array_size_cm')
    parameter_values : np.ndarray
        Array of parameter values to test
    base_config : dict
        Base configuration with all other parameters

    Returns:
    --------
    capacities : np.ndarray
        Array of capacity values (Gbps)
    """
    capacities = []

    for value in parameter_values:
        # Update configuration with current parameter value
        config = base_config.copy()

        if parameter_name == "frequency_ghz":
            result = analyzer.compute_link_budget(
                value,
                config["distance_m"],
                config["array_size_cm"],
                config["array_size_cm"],
            )
        elif parameter_name == "distance_m":
            result = analyzer.compute_link_budget(
                config["frequency_ghz"],
                value,
                config["array_size_cm"],
                config["array_size_cm"],
            )
        elif parameter_name == "array_size_cm":
            result = analyzer.compute_link_budget(
                config["frequency_ghz"], config["distance_m"], value, value
            )
        else:
            raise ValueError(f"Unknown parameter: {parameter_name}")

        capacities.append(result["capacity_gbps"])

    return np.array(capacities)


# ============================================================================
# MODULE TEST
# ============================================================================

if __name__ == "__main__":
    print("\n" + "=" * 80)
    print("CAPACITY ANALYSIS MODULE TEST")
    print("=" * 80)

    # Test 1: Basic link budget calculation
    print("\nTest 1: Link Budget at 200 GHz, 100 m, 5cm arrays")
    print("-" * 80)
    analyzer = CapacityAnalyzer(tx_power_dbm=10, noise_figure_db=10, bandwidth_ghz=10)
    result = analyzer.compute_link_budget(
        frequency_ghz=200, distance_m=100, tx_array_size_cm=5, rx_array_size_cm=5
    )

    print(f"TX Power: {result['tx_power_dbm']:.2f} dBm")
    print(f"TX Gain: {result['tx_gain_dbi']:.2f} dBi")
    print(f"RX Gain: {result['rx_gain_dbi']:.2f} dBi")
    print(f"Path Loss: {result['path_loss_total_db']:.2f} dB")
    print(f"  - Free Space: {result['path_loss_fspl_db']:.2f} dB")
    print(f"  - Absorption: {result['path_loss_absorption_db']:.2f} dB")
    print(f"RX Power: {result['rx_power_dbm']:.2f} dBm")
    print(f"Noise Power: {result['noise_power_dbm']:.2f} dBm")
    print(f"SNR: {result['snr_db']:.2f} dB")
    print(f"Capacity: {result['capacity_gbps']:.2f} Gbps")
    print(f"Spectral Efficiency: {result['spectral_efficiency']:.2f} bits/s/Hz")
    print(f"Link Margin: {result['link_margin_db']:.2f} dB")

    # Test 2: Find required array size
    print("\nTest 2: Array Size Required for 50 Gbps at 200 GHz, 100 m")
    print("-" * 80)
    target = 50.0  # Gbps
    required_size, final_result = analyzer.find_required_array_size(
        frequency_ghz=200, distance_m=100, target_capacity_gbps=target
    )

    print(f"Target Capacity: {target:.2f} Gbps")
    print(f"Required Array Size: {required_size:.2f} cm × {required_size:.2f} cm")
    print(f"Achieved Capacity: {final_result['capacity_gbps']:.2f} Gbps")
    print(f"Required Gain per Array: {final_result['tx_gain_dbi']:.2f} dBi")
    print(f"Final SNR: {final_result['snr_db']:.2f} dB")

    # Test 3: Environmental impact
    print("\nTest 3: Environmental Impact on Capacity")
    print("-" * 80)

    # Standard atmosphere
    analyzer_std = CapacityAnalyzer(env_params=EnvironmentalParams())
    result_std = analyzer_std.compute_link_budget(300, 100, 5, 5)

    # Tropical (hot and humid)
    analyzer_trop = CapacityAnalyzer(
        env_params=EnvironmentalParams(temperature_k=305, humidity_percent=85)
    )
    result_trop = analyzer_trop.compute_link_budget(300, 100, 5, 5)

    print(f"300 GHz, 100 m, 5cm arrays:")
    print(f"Standard Atmosphere: {result_std['capacity_gbps']:.2f} Gbps")
    print(f"Tropical (hot/humid): {result_trop['capacity_gbps']:.2f} Gbps")
    print(
        f"Capacity Reduction: {result_std['capacity_gbps'] - result_trop['capacity_gbps']:.2f} Gbps "
        + f"({(1 - result_trop['capacity_gbps']/result_std['capacity_gbps'])*100:.1f}%)"
    )

    print("\n" + "=" * 80)
    print("✓ Capacity analysis module loaded successfully")
    print("=" * 80 + "\n")
